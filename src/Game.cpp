/*
  SGPacMan - Pacman Super Game Fabric
  Copyright (C) 2010-2011 Rasputtim <Rasputtim@hotmail.com>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  */
#ifdef printf
#undef printf
#endif

#include "Game.h"
#include "Settings.h"
#include "PacGlobal.h"

class CConfiguration;
#define BACKGROUND 0
#define PAC	1
#define GHOST1 2
#define GHOST2 3
#define GHOST3 4
#define GHOST4 5

extern CPacConfiguration settings;

bool Game::showfps=false;

void Game::editorSave() {
    int i=-1, j=-1;

    if ( settings.m_baddiestartx.getInteger() == -1 ||
         settings.m_baddiestarty.getInteger() == -1 ||
         settings.m_pacstartx.getInteger() == -1 ||
         settings.m_pacstarty.getInteger() == -1 ) {
        std::cerr << "Specify pacman and ghost start locations before saving\n";
        return;
    }

    //save

    std::ofstream file;
    bool error=0;		//1 on error


    if (editorpath == "") editorpath = "./levels/new/";
    file.open( (editorpath + MAPFILE).c_str()/*, std::ios::out */);

    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions mapfile generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.m_fieldheight.getInteger(); j++) {
            for (i=0;i<settings.m_fieldwidth.getInteger(); i++) {
               // file << map[j*settings.m_fieldwidth.getInteger()+i] << "  ";
				fieldMap.setTyleType(j,i,atoi(" "));
				file << fieldMap.getTyleType(i,j);
            }
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();


    file.open( (editorpath + OBJFILE).c_str() );
    if (!file) error=1;

    if (!error) {
        file << "/ Pacman Revolutions objectmap generated by Pacman level editor"	<< std::endl;
        for (j=0;j<settings.m_fieldheight.getInteger(); j++) {
            for (i=0;i<settings.m_fieldwidth.getInteger(); i++) {
                //file << objmap[j*settings.m_fieldwidth.getInteger()+i] << "  ";
				objMap.setTyleType(j,i,atoi(" "));
				file << objMap.getTyleType(i,j);
			}
            file << std::endl;
        }
    }

    if (file.is_open() ) file.close();

    file.open ( ( editorpath + CFGFILE ).c_str());
    if (!file) error=true;

    if (!error) {
        file << "/ Pacman Revolutions config file generated by Pacman level editor =;"	<< std::endl;
        file << "FIELDWIDTH=" << settings.m_fieldwidth.getInteger() << ";" << std::endl;
        file << "FIELDHEIGHT=" << settings.m_fieldheight.getInteger() << ";" << std::endl;
        file << "TILESIZE=" << settings.m_tilesize.getInteger() << ";" << std::endl;
        file << "PACSPEED=" << settings.m_pacspeed.getInteger() << ";" << std::endl;
        file << "BADDIESPEED=" << settings.m_baddiespeed.getInteger() << ";" << std::endl;
        file << "BADDIEIQ=" << settings.m_baddieiq.getInteger() << ";" << std::endl;
        file << "VULN_DURATION=" << settings.m_vuln_duration.getInteger() << ";" << std::endl;
        file << "PACSTARTX=" << settings.m_pacstartx.getInteger()  << ";" << std::endl;
        file << "PACSTARTY=" << settings.m_pacstarty.getInteger() << ";" << std::endl;
        file << "BADDIESTARTX=" << settings.m_baddiestartx.getInteger() << ";" << std::endl;
        file << "BADDIESTARTY=" << settings.m_baddiestarty.getInteger() << ";" << std::endl;
    }
    if ( file.is_open() ) file.close();

    bool isincluded = false;
    for (i=0;i< settings.lvlpathcount;i++) {
        if ( editorpath == settings.lvlpath[i] ) isincluded = true;
    }
    if ( !isincluded && !error) {
        file.open("pacman.cfg", std::ios::out | std::ios::app);
        if (!file) error=true;
        else {
            file << "\nLEVEL_PATH=" << editorpath;
            if (file.is_open()) file.close();
            settings.lvlpath.push_back(editorpath);
            settings.lvlpathcount++;
        }
    }


    if (error) {
        std::cerr << "Save failed";
    }
}

void Game::logicEditor() {

    if ( inputwaiting) {
        if ( key == Left ) {

            if ( activetool <= 0 ) activetool = 15;
            else activetool--;
        }
        else if ( key == Right ) {

            if ( activetool >= 15 ) activetool = 0;
            else activetool++;
        }
        else if ( key == Click ) {
			if (activetool < 10)
				fieldMap.setTyleType(mouseX / settings.m_tilesize.getInteger(),mouseY / settings.m_tilesize.getInteger(),activetool);

            else if (activetool == 14) {
                settings.m_pacstartx.setInteger( mouseX / settings.m_tilesize.getInteger());
                settings.m_pacstarty.setInteger( mouseY / settings.m_tilesize.getInteger());
            }
            else if (activetool == 15 ) {
                settings.m_baddiestartx.setInteger(  mouseX / settings.m_tilesize.getInteger());
                settings.m_baddiestarty.setInteger(  mouseY / settings.m_tilesize.getInteger());
            }
            else
				objMap.setTyleType((mouseX-10) / settings.m_tilesize.getInteger(),(mouseY - 10) / settings.m_tilesize.getInteger(),activetool-10);
       }
    }

}

void Game::renderEditor() {
    int i;

    objects[BACKGROUND]->draw();

    for (i=1;i<10;i++) {
        if ( i == activetool )
            ((BckgrObj*)objects[BACKGROUND])->Draw( 10 + 30*i, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 , i, 0, 255);
        else
            ((BckgrObj*)objects[BACKGROUND])->Draw( 10 + 30*i, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 , i, 0, 100);
    }
    for (i=1;i<4;i++) {
        if ( i == activetool - 10 )
            ((BckgrObj*)objects[BACKGROUND])->Draw( 310 + 30*i, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 , i, 1, 255);
        else
            ((BckgrObj*)objects[BACKGROUND])->Draw( 310 + 30*i, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 , i, 1, 100);
    }
    if ( activetool == 14 ) {
        (objects[PAC])->setAlpha(255);
        (objects[PAC])->draw(NULL,430, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 );
    }
    else {
        (objects[PAC])->setAlpha(100);
        (objects[PAC])->draw(NULL,430, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 );
    }
    if ( activetool == 15 ) {
        (objects[GHOST1])->setAlpha(255);
        (objects[GHOST1])->draw(NULL,480, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 );
    }
    else {
        (objects[GHOST1])->setAlpha(100);
        (objects[GHOST1])->draw(NULL,480, settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() + 5 );
    }

     (objects[PAC])->draw(NULL,settings.m_pacstartx.getInteger()*settings.m_tilesize.getInteger(), settings.m_pacstarty.getInteger() * settings.m_tilesize.getInteger() );
    (objects[GHOST1])->draw(NULL,settings.m_baddiestartx.getInteger() * settings.m_tilesize.getInteger(), settings.m_baddiestarty.getInteger() * settings.m_tilesize.getInteger());

}

void Game::initEditor() {
    gameControl->getSnd()->stop();
    fieldMap.reset();
	objMap.reset();
    //create new empty maps
    if ( editorpath == "" ) {
        fieldMap.resize(settings.m_fieldheight.getInteger() , settings.m_fieldwidth.getInteger());
		fieldMap.setTileSize(settings.m_tilesize.getInteger());
		objMap.resize(settings.m_fieldheight.getInteger() , settings.m_fieldwidth.getInteger());
		objMap.setTileSize(settings.m_tilesize.getInteger());

        settings.m_baddiestartx.setInteger(-1);
        settings.m_baddiestarty.setInteger(-1);
        settings.m_pacstartx.setInteger(-1);
        settings.m_pacstarty.setInteger(-1);
        settings.m_gatex.setInteger(-1);
        settings.m_gatey.setInteger(-1);
    }
    //load existing map
    else {

        //load settings

		settings.loadConfigurations( editorpath + CFGFILE );

        //if level has different field size than currently selected, setup new window with proper size
		if (settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() != gameControl->getScreen()->getWidth()
			|| settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger()+EXTRA_Y_SPACE != gameControl->getScreen()->getHeight()) {
           // app.InitWindow();
            Debug::debug(Debug::error,__FUNCTION__)<<"window resized..."<<endl;
        }

        //load maps

        fieldMap.resize(settings.m_fieldheight.getInteger() , settings.m_fieldwidth.getInteger());
		objMap.resize(settings.m_fieldheight.getInteger() , settings.m_fieldwidth.getInteger());
		fieldMap.loadCharMap( editorpath + MAPFILE);
		objMap.loadCharMap( editorpath + MAPFILE);
        //if loading is successful, set editorpath

    }

}
void Game::changeSkin() {
    int i;

	for (i=0;i<NUMOFOBJECTS;i++) {
		(objects[i])->setObjectPath(settings.skinspath[settings.m_skinspathcurrent.getInteger()]);
		objects[i]->load();
	}
}

void Game::run(Game & thisGame){
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN RUN THE GAME==========================" << endl;

    struct GameState{
        GameState():
            endMatch(false){
            }

        bool endMatch;
    };

    class Logic: public Input::CLogic {
    public:
        Logic(GameState & state, Game * thisGame):
        CLogic(GS_Const_InDep_FPS_Var), //GS_Dep_FPS_Var / GS_Const_FPS_Max
		state(state),
        pacGame(thisGame),
		xpos(0),
		ypos(0)
		{


            /* FIXME: use an enum here */
			gameInput.set(CKeyboard::Key_UP, 10, false, Up);
			gameInput.set(CKeyboard::Key_DOWN, 10, false, Down);
            gameInput.set(CKeyboard::Key_LEFT, 10, false, Left);
            gameInput.set(CKeyboard::Key_RIGHT, 10, true, Right);
			gameInput.set(CKeyboard::Key_ENTER, 0, true, Select);
			gameInput.set(CKeyboard::Key_ESC, 0, true, 6);
			gameInput.set(CKeyboard::Key_SPACE, 0, true, 7);
			gameInput.set(CKeyboard::Key_P, 0, true, 8);
			gameInput.set(CKeyboard::Key_S, 10, true, 9);
			gameInput.set(CKeyboard::Key_E, 0, true, 10);
			gameInput.set(CKeyboard::Key_W, 0, true, 11);
			gameInput.set(CKeyboard::Key_F, 0, true, 12);
			gameInput.set(CKeyboard::Key_N, 0, true, 13);
			gameInput.set(CKeyboard::Key_L, 0, true, 14);
			gameInput.set(CKeyboard::Key_Q, 0, true, 15);
			gameInput.set(CKeyboard::Key_H, 0, true, 17);
			gameInput.set(CKeyboard::Key_T, 0, true, 18);
			//gameInput.set(CMouse::Key_MoveLEFT, 0, true, Left);
			//gameInput.set(CMouse::key_MoveRIGHT, 0, true, Right);
			gameInput.set(CMouse::Key_LEFT, 0, true, Click);
			//gameInput.set(CMouse::Key_MoveUP,0,true,Up);
			//gameInput.set(CMouse::Key_MoveDOWN,0,true,Down);
            //gameInput.set(SGF::CConfiguration::config(0).getJoystickQuit(), 0, true, 4);
            gameInput.set(CKeyboard::Key_F5, 10, true, 5);
        }
		//! Keys
        CInputMap<int> gameInput;
        GameState & state;
        Game *pacGame;
        int xpos;
		int ypos;



     void doInput(){

 	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN FASE 1 - Get Events "<<  endl;
	 vector<CInputMap<int>::InputEvent> events = CInputManager::getEvents(gameInput);
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "END FASE 1 - Got Events: "<< events.size()<<  endl;
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN FASE 2 - Proccess Events "<<  endl;

    for (vector<CInputMap<int>::InputEvent>::iterator it = events.begin(); it != events.end(); it++){
        const CInputMap<int>::InputEvent & event = *it;

		if (!event.enabled){
            continue;
        }

        if (event.out == Cancel){
                 pacGame->doAction(Cancel) ;
        }

       	Debug::debug(Debug::gameEngine,__FUNCTION__) << "Will Begin Doing Actions:  "<< event.out <<  endl;

        switch (event.out){
                case Up: pacGame->doAction(Up); break;
                case Down: pacGame->doAction(Down); break;
                case Left: pacGame->doAction(Left); break;
                case Right: pacGame->doAction(Right); break;
				case Select: pacGame->doAction(Select); break;
				case 6: pacGame->doAction(Cancel); break;
				case 7: pacGame->doAction(Modify); break;
				case 8: pacGame->doAction(Pause); break;
				case 9: pacGame->doAction(ChangeSkin); break;
				case 10: pacGame->doAction(InitEditor); break;
				case 11: pacGame->doAction(SaveEditor); break;
				case 12: pacGame->doAction(ShowFPS); break;
				case 13: pacGame->doAction(ActionN); break;
				case 14: pacGame->doAction(ChangeLevel); break;
				case 15: pacGame->doAction(ActionH); break;
                case 16: {
						pacGame->doAction(Click,event.mouseXpos,event.mouseYpos);
						Debug::debug(Debug::gameEngine,__FUNCTION__) << "Click Detected [x,y] "<< event.mouseXpos << " , "<< event.mouseYpos<<  endl;
						break;
						 }
                case 17: pacGame->doAction(Help); break;
				case 18: pacGame->doAction(TogleSound); break;
                default: break;
            }

		}

		}

        virtual void run(int delay){
            // Do stage logic catch match exception to handle the next match
			Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL RUN THE STAGE LOGIC=========================" << endl;

			pacGame->processLogic();
            //state.endMatch = stage->isMatchOver();

			Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN DO THE INPUT=========================" << endl;

            doInput();
			Debug::debug(Debug::gameEngine,__FUNCTION__) << " END DO THE INPUT=========================" << endl;

        }

        virtual bool done(){
			return pacGame->getGameControl()->getQuit();
        }

        virtual double ticks(double system){
          //  return Util::gameTicks(system, 0.1); //0.1 = gamespeed
	int TheSpeed = 60;  //uma velocidade de gamespeed = 0.1  e ticks por segund = 60
    double valor = system * 0.1 * TheSpeed / CGlobalConfiguration::gameFPS.getInteger();
	return valor;
        }
    };

    class Draw: public Input::CDraw {
    public:
        Draw(Game * stage):
            pacGame(stage),
			work(SGF::CConfiguration::screenWidth.getInteger(),SGF::CConfiguration::screenHeight.getInteger()){
            }

        Game * pacGame;
        SGF::CBitmap work;

        virtual void draw(double fps){

			Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL RENDER EVERYTHING to Work: [(CBitmao:: "<< &work<<" ) (Surface: "<< work.getBitmap()<<" )]=========================" << endl;

			work.clear();
			pacGame->act();

            Debug::debug(Debug::gameEngine,__FUNCTION__) << " EVERYTHING IS RENDERED =========================" << endl;

			if (showfps){
				CResource::getDefaultFont()->DrawTextNew(0,pacGame->gameControl->getScreen()->getHeight()-80,Colors::White, work,"%2.2f FPS",fps);

				Debug::debug(Debug::gameEngine,__FUNCTION__) << " FRAME y =========================" <<pacGame->gameControl->getScreen()->getHeight()-100<< endl;
           }
			//work.updateTexture();
			work.BlitToScreen();

        }
    };

    GameState state;
    Logic logic(state,&thisGame); // this não pode ser usado aqui por ser um método estático
    Draw draw(&thisGame);
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " BEGIN DRAW =========================" << endl;
	//Executa aqui o loop do Jogo
	Input::SGE_standardLoop(logic, draw);
	Debug::debug(Debug::gameEngine,__FUNCTION__) << " END DRAW =========================" << endl;

	Debug::debug(Debug::gameEngine,__FUNCTION__) << " END RUN THE MATCH==========================" << endl;

}


void Game::doAction(Actions Action, int mousex, int mousey) {

	Debug::debug(Debug::gameEngine,__FUNCTION__) << "WILL EXECUTE ACTION:  "<< Action <<  endl;


        switch(Action) {


            case Cancel:
                gameControl->setQuit(true);
                break;
            case Up:
                processInput(Up);
                ((Pacman*)objects[PAC])->setNextDir( Up );
                break;
            case Down:
                processInput(Down);
                ((Pacman*)objects[PAC])->setNextDir( Down );
                break;
            case Left:
                processInput(Left);
				((Pacman*)objects[PAC])->setNextDir( Left );
                break;
            case Right:
                processInput(Right);
                ((Pacman*)objects[PAC])->setNextDir( Right );
                break;
            case Modify:
                boost();
                break;
            case Pause:
                if ( getState() == STATE_GAME )
                    pause();
                break;
            case ActionN:
                if ( getState() != STATE_ENTER_HSCORE )
                    gameInit();
                break;
            case ChangeLevel:
				settings.m_lvlpathcurrent.setInteger(settings.m_lvlpathcurrent.getInteger()+1);
                if ( settings.m_lvlpathcurrent.getInteger() >= settings.lvlpathcount)
                    settings.m_lvlpathcurrent.setInteger(0);
                gameInit();
                break;
            case ChangeSkin:
                settings.m_skinspathcurrent.setInteger(settings.m_skinspathcurrent.getInteger()+1);
                if ( settings.m_skinspathcurrent.getInteger() >= settings.skinspathcount)
                    settings.m_skinspathcurrent.setInteger(0);
                changeSkin();
                break;
            case InitEditor:
                initEditor();
                setState( STATE_EDITOR );
                break;
            case SaveEditor:
                //                        std::cerr << "w: save map not yet implemented";
                editorSave();
                break;
            case ShowFPS:
                toggleFps();
                break;
            case ActionH:
                setState( STATE_VIEW_HSCORE );
                break;
            case Select:
                processInput(Select);
                break;
            case Help:
                if ( getState() == STATE_GAME )
                    help();
                break;
			case Click:

				 if ( getState() == STATE_EDITOR )
					processInput( Click, mousex, mousey);
            break;
			case TogleSound:
				toggleSound();
			break;
            default:
                break;
            }


}



void Game::toggleSound() {

    if (gameControl->getSnd()->on) {
       gameControl->getSnd()->toggleSounds();
    }
    else {
       gameControl->getSnd()->toggleSounds();

        if (gamestarted && !ispaused )gameControl->getSnd()->play(10, 1);
        if (gamestarted && vulnflag && !ispaused )gameControl->getSnd()->play(7, 1);
    }
}
void Game::clearHscore() {
    hscore.clear();
}

void Game::renderViewHscore() {
	SGF::CBitmap *work = gameControl->getWork();

	Colors::ColorDefinition col=Colors::White;
    std::ostringstream ostr, scstr;
    SDL_Rect rect;
    int i, sc;
    std::string nm;

    rect.x = settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() / 2 - 200;
    rect.w = 400;
    rect.y = settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() / 2 - 200;
    rect.h = 50;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
            (objects[PAC])->draw(NULL,350+i*50, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger());
        }
        if ( specialeaten ) ((BckgrObj *)objects[BACKGROUND])->Draw( settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() - 40 -10, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() +10 );

        //CResource::getDefaultFont()->drawText(scorebox.x,scorebox.y,Colors::White, *work,"LEVEL: %d SCORE: %d",level,score);
        // DRAW HIGHSCORES
		CResource::getDefaultFont()->drawText(rect.x,rect.y,col, *work,"%s","HIGHSCORES:");

        for (i=0;i<MAXENTRIES;i++) {

            nm= "";
            nm=hscore.getName(i);
            sc=hscore.getScore(i);

            rect.x = settings.m_fieldwidth.getInteger() * settings.m_tilesize.getInteger() / 4;
            rect.w = 200;
            rect.y = 200 + i*50;
            rect.h = 50;

            if ( nm != "" ) {
				CResource::getDefaultFont()->drawText(rect.x,rect.y,col, *work,"%s",nm.c_str());

            }

            rect.x = settings.m_fieldwidth.getInteger() * settings.m_tilesize.getInteger() / 4 + 200;


            scstr.str("");
            if ( sc ) {
                scstr << sc;
				CResource::getDefaultFont()->drawText(rect.x,rect.y,col, *work,"%s",scstr.str().c_str());

            }
        }

    }
    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in RenderViewHscore";
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected error in RenderViewHscore" <<endl;
    }
}

void Game::setState(int st) {
    int i;

    if ( st == STATE_GAME ) {
       gameControl->getSnd()->stop();
       //gameControl->getSnd()->play(10,1);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]!=NULL) (objects[i])->setAlpha(255);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i]!=NULL ) (objects[i])->setPaused( false);

    }
    else if ( st == STATE_ENTER_HSCORE ) {

       gameControl->getSnd()->stop();

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] !=NULL) (objects[i])->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]!=NULL) (objects[i])->setAlpha(150);

    }
    else if ( st == STATE_VIEW_HSCORE ) {


       gameControl->getSnd()->stop();
       gameControl->getSnd()->play( 11, 0);

        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]!=NULL) (objects[i])->setAlpha(150);
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i]!=NULL ) (objects[i])->setPaused( true);
    }
    else if ( st == STATE_STOPPED && state != STATE_STOPPED) {
       	gameControl->getSnd()->stop();
		gameControl->getSnd()->play(0, 1);
	   
        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i]!=NULL ) (objects[i])->setPaused( true);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]!=NULL) (objects[i])->setAlpha(255);
    }
    else if ( st == STATE_EDITOR ) {

        gameControl->getSnd()->stop();
		gameControl->getSnd()->stop(10);
        for (i=0;i<NUMOFOBJECTS;i++) if (objects[i]!=NULL) (objects[i])->setAlpha(255);

        activetool = 1;
    }

    state = st;

}

void Game::logicEnterHscore() {
    int j;

    if ( inputwaiting ) {

        switch ( key ) {
        case Right :
            if (hscoreselection==2) hscoreselection=0;
            else hscoreselection++;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case Left :
            if (hscoreselection==0) hscoreselection=2;
            else hscoreselection--;
            for (j=0;j<3;j++) namecol[j]= 150;
            namecol[ hscoreselection ] = 255;
            break;
        case Down :
            if (name[hscoreselection]=='A') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='Z';
            else name[hscoreselection]--;
            break;
        case Up :
            if (name[hscoreselection]=='Z') name[hscoreselection]='_';
            else if (name[hscoreselection]=='_') name[hscoreselection]='A';
            else name[hscoreselection]++;
            break;
        case Select :
            hscore.add(name, score);
            hscore.save();

            setState( STATE_VIEW_HSCORE) ;
        default :
             break;
        }
    }
}
void Game::logicGame() {
    int
            i, j,
            delta,
            pacX,
            pacY,
            pacXpix,
            pacYpix,
            ghostXpix[4],
            ghostYpix[4],
            oldscore(score);

    delta = (int)(time -oldtime);

    if ( gamestarted && !ispaused ) {
		Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL START GAME LOGIC" << endl;
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "(1) - GET POSITONS" << endl;
        //////////////////////////////////
        //	GET POSITIONS
        //////////////////////////////////

        pacXpix = ((Pacman*)objects[PAC])->getXpix();
        pacYpix = ((Pacman*)objects[PAC])->getYpix();
        pacX= (pacXpix + settings.m_tilesize.getInteger() / 2) / settings.m_tilesize.getInteger();
        pacY= (pacYpix + settings.m_tilesize.getInteger() / 2) / settings.m_tilesize.getInteger();
		Debug::debug(Debug::gameEngine, __FUNCTION__) << "----------------------------------------"<< endl;
		Debug::debug(Debug::gameEngine, __FUNCTION__) << "PACMAN MAP POSITION[ "<< pacX<<" , "<<pacY<<" ]"<< fieldMap.getTyleType(pacX,pacY) << (fieldMap.getTyleType(pacX,pacY)==0?" WALKABLE": "NOT WALKABLE")<< endl;
		Debug::debug(Debug::gameEngine, __FUNCTION__) << "PACMAN MAP POSITION[ "<< pacX<<" , "<<pacY+1<<" ]: "<<fieldMap.getTyleType(pacX,pacY+1)<< (fieldMap.getTyleType(pacX,pacY+1)==0?" WALKABLE": "NOT WALKABLE")<< endl;
		Debug::debug(Debug::gameEngine, __FUNCTION__) << "PACMAN MAP POSITION[ "<< pacX+1<<" , "<<pacY<<" ]"<< fieldMap.getTyleType(pacX+1,pacY)<< (fieldMap.getTyleType(pacX+1,pacY)==0?" WALKABLE": "NOT WALKABLE")<< endl;
		Debug::debug(Debug::gameEngine, __FUNCTION__) << "PACMAN MAP POSITION[ "<< pacX+1<<" , "<<pacY+1<<" ]"<< fieldMap.getTyleType(pacX+1,pacY+1) <<(fieldMap.getTyleType(pacX+1,pacY+1)==0?" WALKABLE": "NOT WALKABLE")<< endl;
		for (i=0;i<4;i++) {
            ghostXpix[i]= ((Ghost*)objects[i+2])->getXpix();
            ghostYpix[i]= ((Ghost*)objects[i+2])->getYpix();
        }

        //////////////////////////////////
        // MOVE LOGIC
        //////////////////////////////////

        if ( delta < 100 )  {
            //set ghost targets - 2 on pacman, 2 on next intersection
			Debug::debug(Debug::gameEngine,__FUNCTION__) << "(2) - MOVE OBJCTS" << endl;

            {
                int tmpx(  pacXpix / settings.m_tilesize.getInteger()),
                tmpy(  pacYpix / settings.m_tilesize.getInteger());

                ((Ghost*)objects[GHOST1])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST2])->setTarget( tmpx, tmpy);

                ((Pacman*)objects[PAC])->nextIntersection ( tmpx, tmpy);

                ((Ghost*)objects[GHOST3])->setTarget( tmpx, tmpy);
                ((Ghost*)objects[GHOST4])->setTarget( tmpx, tmpy);
            }

            //move objects

            for (i=0;i<NUMOFOBJECTS;i++){
				 //Quake( delta );
                (objects[i])->act(); // delta );
			}
        }
        ///////////////////////////////////////////
        //	TIME LOGIC
        ///////////////////////////////////////////

        //if ghost timer is up, set ghosts to normal mode

        if ( vulnflag && time > ghosttick ) {
            for (i=0;i<4;i++) {
                if ( ((Ghost*)objects[i+2])->getState() != 3) ((Ghost*)objects[i+2])->setState(Ghost::NORMAL);
            }
            vulnflag= false;
            deadghostcount= 0;

           gameControl->getSnd()->stop(7);
        }

        // if less than 2 secs left in vuln mode, set warning mode

        else if ( vulnflag && time > ghosttick -2000) for (i=0;i<4;i++) {
            ((Ghost*)objects[i+2])->setState(Ghost::WARNING);
            //			m_Game.getSnd()->modify( 7, 44100 + (2000 - (ghosttick-time))*10 );
        }

        // fruit stuff

        if ( specialspawned && !specialeaten && (fruittick - time < 2000) ) {
            ((BckgrObj*)objects[BACKGROUND])->setFruitAlpha( 55 + (fruittick - time) / 10 );
        }
        if ( time > fruittick && specialspawned && !specialeaten) {
            specialspawned = false;
            ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(false);
        }

        // pac booster

        if ( isboosted && time > boosttick ) {
            isboosted = false;
            ((Pacman*)objects[PAC])->setSpeedMult( 1 );
        }

        ///////////////////////////////////////////
        // PACMAN LOCATION LOGIC
        ///////////////////////////////////////////
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "(3) - VERIFY COLISION WITH OTHER OBJECTS" << endl;
        for (i=0; i< 4; i++) {
            //if (pacX == baddieX[i] && pacY == baddieY[i] ) {
            if (	pacXpix > ghostXpix[i] - 10  &&
                        pacXpix < ghostXpix[i] + 10  &&
                        pacYpix > ghostYpix[i] - 10  &&
                        pacYpix < ghostYpix[i] + 10  ) {

                if ( ((Ghost*)objects[i+2])->getState() == 0 )	{

                    lives--;

                   gameControl->getSnd()->stop();
                   gameControl->getSnd()->play(8, 0);

                    SDL_Delay(1000);

                    if ( lives == 0) {
                        if (hscore.onlist(score) ) setState( STATE_ENTER_HSCORE );
                        else gameInit();
                        return;
                    }
                    else {
                        reloadLevel();
                        return;
                    }
                }

                else if  ( ((Ghost*)objects[i+2])->getState() != 3 ) {
					((Ghost*)objects[i+2])->setState(Ghost::DEAD);

                   gameControl->getSnd()->play(4,0);
                    deadghostcount++;

                    floatingscore = 200;
                    for (j=1; j< deadghostcount; j++) floatingscore *= 2;
                    floatingscorebox.x = pacXpix;
                    floatingscorebox.w = 100;
                    floatingscorebox.y = pacYpix-70;
                    floatingscorebox.h = 50;

                    floatingscorecounter = 100;

                    score+= floatingscore;
                }
            }
        }

		if ( objMap.getTyleType(pacX,pacY) == 1 ) {
            objMap.setTyleType(pacX,pacY,0);
            score += SMALL_DOTS_SCORE;

           gameControl->getSnd()->play( 1 + soundcounter%2, 0, -500);
            soundcounter++;
        }
		else if ( objMap.getTyleType(pacX, pacY) == 2 ) {
            objMap.setTyleType(pacX, pacY,0);
            score += LARGE_DOTS_SCORE;

           gameControl->getSnd()->play(3, 0);
           gameControl->getSnd()->play(7, 1);

            //set ghosts to vulnerable mode

            for (i=2;i<6;i++) ((Ghost*)objects[i])->setState(Ghost::VULNERABLE);
            deadghostcount=0;	//reset dead counter

            //start ghost timer

            ghosttick = time + settings.m_vuln_duration.getInteger();
            vulnflag = true;
        }
        else if (objMap.getTyleType(pacX, pacY)== 3 &&  specialspawned && !specialeaten ) {
            objMap.setTyleType(pacX, pacY,0);
            score += objscore;

           gameControl->getSnd()->play(5, 0);

            floatingscorebox.x = pacXpix;
            floatingscorebox.w = 100;
            floatingscorebox.y = pacYpix-70;
            floatingscorebox.h = 50;
            floatingscore = objscore;
            floatingscorecounter = 100;

            specialeaten = true;
            ((BckgrObj*)objects[BACKGROUND])->setSpecialEaten(true);
        }


        ///////////////////////////////////
        //	OTHER
        ///////////////////////////////////

        if ( (score >= 10000 && oldscore < 10000) ||
             (score >=100000 && oldscore < 100000) ||
             (score >=1000000 && oldscore < 1000000) ) {
            lives++;

           gameControl->getSnd()->play(6, 0);
        }

        if ( !specialhasbeenspawned && ((BckgrObj*)objects[BACKGROUND])->getObjCount() == specialspawntime) {
            specialspawned = true;
            ((BckgrObj*)objects[BACKGROUND])->setFruitAlpha(255);
            ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(true);
            fruittick = SDL_GetTicks() + FRUITDURATION;
        }

        if ( ((BckgrObj*)objects[BACKGROUND])->getObjCount() == 0 ) {
            levelcleared = true;
            act();
            nextLvl();
        }
        //		else (gameControl->getSnd()->modify( 10, 44100 - ((BckgrObj*)objects[BACKGROUND])->getObjCount() * 75) );
    }
}
void Game::renderEnterHscore() {

    std::ostringstream ostr;
    SDL_Rect rect;
    Colors::ColorDefinition col;
    int i;
    std::string tmp;

    col.r = col.g = col.b = 255;

    rect.x = settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() / 2 - 200;
    rect.w = 400;
    rect.y = settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() / 2 - 50;
    rect.h = 50;

    try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) objects[i]->draw();

        // DRAW SCORE + INFO

        for (i=1; i<lives; i++) {
             (objects[PAC])->draw(NULL,350+i*50, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger()+5);
        }
        if ( specialeaten ) ((BckgrObj*)objects[BACKGROUND])->Draw( settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() - 40 -10, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() +15 );

		//if (CResource::getDefaultFont()) {
		CResource::getDefaultFont()->DrawTextNew(scorebox.x,scorebox.y,col,*this->gameControl->getScreen(),"LEVEL: %d   SCORE: %d",level,score);

        // DRAW HIGHSCORE ENTRY

		CResource::getDefaultFont()->DrawTextNew(rect.x,rect.y,col,*this->gameControl->getScreen(),"%s","NEW HIGHSCORE!");
		//}

        rect.y += 50;
		//if (CResource::getDefaultFont())
		CResource::getDefaultFont()->DrawTextNew(rect.x,rect.y,col,*this->gameControl->getScreen(),"%s","Enter name:");

        rect.y += 70;
        rect.h = 50;
        rect.x = settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() / 2 - 60;
        rect.w = 40;

        for (i=0;i<3;i++) {
            tmp=name[i];
            col.r=col.g=col.b=namecol[i];
			//if (CResource::getDefaultFont())
			CResource::getDefaultFont()->DrawTextNew(rect.x,rect.y,col,*this->gameControl->getScreen(),"%s",tmp.c_str());

            rect.x=rect.x+40;
        }
    }
    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::RenderEnterHscore";
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected error in Game::RenderEnterHscore" <<endl;
    }
}
void Game::showEditorHelpScreen() {

						ostringstream out;
						out << "TECLA -> AÇÃO                \n";
						out << "_____________________________\n";
						out << "(H) -> Mostra tela de Help\n";
						out << "(P) -> Pausa o Jogo \n";
						out << "(Q) -> Mostra HSore \n";
						out << "(S) -> Muda Skin\n";
						out << "(E) -> Inicia Editor\n";
						out << "(W) -> Salva Editor \n";
						out << "(F) -> Mostra FPS\n";
						out << "(N) -> Reinicia o Game\n";
						out << "(L) ->  Muda de Level\n";
						out << "(Enter) -> Inicio\n";
						out << "(ESC) -> Sai\n";
						out << "(SPACE) -> Boost \n";


						const CFont *font = (CFont *) CResource::getDefaultFont();
						SGF::Util::popup(*font, out.str());
}

void Game::showHelpScreen() {

						ostringstream out;
						out << "TECLA -> AÇÃO                \n";
						out << "_____________________________\n";
						out << "(H) -> Mostra tela de Help\n";
						out << "(P) -> Pausa o Jogo \n";
						out << "(Q) -> Mostra HSore \n";
						out << "(S) -> Muda Skin\n";
						out << "(E) -> Inicia Editor\n";
						out << "(W) -> Salva Editor \n";
						out << "(F) -> Mostra FPS\n";
						out << "(N) -> Reinicia o Game\n";
						out << "(L) ->  Muda de Level\n";
						out << "(Enter) -> Inicio\n";
						out << "(ESC) -> Sai\n";
						out << "(SPACE) -> Boost \n";


						const CFont *font = (CFont *) CResource::getDefaultFont();
						SGF::Util::popup(*font, out.str());
}
void Game::draw( SGF::CBitmap * work ) {
    int i;
    std::ostringstream ostr;
    Colors::ColorDefinition col;
    col.r = col.g = col.b = 255;

    //s try {
        // DRAW FIELD + SPRITES

        for (i=0;i<NUMOFOBJECTS;i++) {
			if ( objects[i] ) objects[i]->draw();
			//SGF::CBitmap::BlitRenderToScreen(0);
		}
            
        // DRAW SCORE + INFO

        for (i=1; i<lives; i++)
            if ( objects[PAC] ) (objects[PAC])->draw(NULL,350+i*50, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger()+5);

        if ( specialeaten ) if ( objects[BACKGROUND] )((BckgrObj*)objects[BACKGROUND])->Draw( settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() - 40 -10, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() +15 );
        if ( boostavailable ) if ( objects[BACKGROUND] ) ((BckgrObj*)objects[BACKGROUND])->Draw( settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() - 60 -10, settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() +15, 4 );

		//if (CResource::getDefaultFont()) {
			CTTFFont *tempfont=CResource::getDefaultFont();
			tempfont->drawToTexture( scorebox.x,scorebox.y, col, *this->gameControl->getScreen(),"LEVEL: %d   SCORE: %d",level,level,score) ;
			//this->gameControl->getScreen()->Render("TESTE", 100,100,col,tempfont);
//			tempfont->DrawTextNew(scorebox.x,scorebox.y,col,*this->gameControl->getScreen(),"LEVEL: %d   SCORE: %d",level,score);

		//}

        //DRAW SCORE POPUP
        if (floatingscorecounter != 0) {
            std::ostringstream scoretext;

            scoretext << floatingscore;
            floatingscorecounter--;

            floatingscorebox.y--;
			//SDL_SetAlpha(txt,SDL_SRCALPHA,	55+floatingscorecounter*2);
			//if (CResource::getDefaultFont())
			CResource::getDefaultFont()->DrawTextNew(floatingscorebox.x,floatingscorebox.y,col,*this->gameControl->getScreen(),"%s",scoretext.str().c_str());

        }

        // PAUSE

        if ( ispaused ) {
            SDL_Rect pauserect;
            pauserect.y = settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() / 2 - 100;
            pauserect.w = 200;
            pauserect.x = settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() / 2 - 10;
            pauserect.h = 50;
			CResource::getDefaultFont()->DrawTextNew(pauserect.x,pauserect.y,col,*this->gameControl->getScreen(),"%s","PAUSED");
            if ( showHelp ) showHelpScreen();
        }

        // LEVEL CLEARED

        else if ( levelcleared ) {
            SDL_Rect pauserect;
            pauserect.x = settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() / 2 - 200;
            pauserect.w = 400;
            pauserect.y = settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger() / 2 - 10;
            pauserect.h = 50;
			//if (CResource::getDefaultFont())
			CResource::getDefaultFont()->DrawTextNew(pauserect.x,pauserect.y,col,*this->gameControl->getScreen(),"%s","LEVEL CLEARED!");

        }
 /*  }

    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch ( ... ) {
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception"<< endl;
		gameControl->setQuit(true);

    } */
}

void Game::boost() {
    if ( boostavailable ) {

       gameControl->getSnd()->play( 12, 0 );

        boosttick = SDL_GetTicks() + BOOSTTIME;
        isboosted = true;
        boostavailable = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 2 );
    }
}
void Game::help() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
        gameControl->getSnd()->stop();
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused(true);

        pausetick = SDL_GetTicks();
		showHelp = true;

    }
    else {
        ispaused = false;
		showHelp = false;
       gameControl->getSnd()->play(10, 1);
        if (vulnflag)gameControl->getSnd()->play(7, 1);
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;


    }
}
void Game::pause() {
    int i;

    if ( !ispaused ) {
        ispaused = true;
       gameControl->getSnd()->stop();
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused(true);

        pausetick = SDL_GetTicks();


    }
    else {
        ispaused = false;
       gameControl->getSnd()->play(10, 1);
        if (vulnflag)gameControl->getSnd()->play(7, 1);
        for (i=0;i<NUMOFOBJECTS;i++) (objects[i])->setPaused( false);

        int delta( SDL_GetTicks() - pausetick );

        ghosttick += delta;
        fruittick += delta;
        boosttick += delta;


    }
}
void Game::nextLvl() {
    std::string tmpstr;


    try {
        level++;

       gameControl->getSnd()->stop();
       gameControl->getSnd()->play(9);

        objscore*=2;
        settings.m_vuln_duration.setInteger( settings.m_vuln_duration.getInteger()-settings.m_vuln_duration.getInteger()/10);

        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%15, rand()%5 );
        ((Ghost*)objects[ rand()%4 +2])->changeDifficulty( rand()%10, rand()%3 );

        objects[PAC]->reset();
        objects[GHOST1]->reset();
        objects[GHOST2]->reset();
        objects[GHOST3]->reset();
        objects[GHOST4]->reset();

        tmpstr = settings.lvlpath[settings.m_lvlpathcurrent.getInteger()] + OBJFILE;
        if ( ! objMap.loadCharMap(tmpstr) )
            throw SMF::Exception::CGeneralError("SMF::Exception::CGeneralError loading objmap.txt during Game::nextLvl()");

        vulnflag= false;
        deadghostcount= 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        specialspawned = false;
        ((BckgrObj*)objects[BACKGROUND])->setSpecialSpawned(false);
        specialeaten = false;
        ((BckgrObj*)objects[BACKGROUND])->setSpecialEaten(false);
        specialhasbeenspawned = false;
        time = oldtime = SDL_GetTicks();
        ghosttick = 0;
        isboosted = false;
        ((Pacman*)objects[PAC])->setSpeedMult( 1);
        boostavailable = true;
        levelcleared = false;

        if (ispaused) pause();


        SDL_Delay(1000);


        act();
        specialspawntime = rand() % (((BckgrObj*)objects[BACKGROUND])->getObjCount() -20) + 10;

        //emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;
    }
    catch ( SMF::Exception::CGeneralError &err) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::nextLvl()";
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected error in Game::nextLvl()" <<endl;
    }
}

void Game::gameInit(std::string mylevel, std::string skin, bool editor) {
    int i;
    std::string tmpstr;

    // try {
        isinit=false;
        //m_Game.getSnd()->stop();

        //try to set level/skins path
        settings.setPath(MODE_LEVELS,mylevel);
        settings.setPath(MODE_SKINS,skin);
		int curconfig=settings.m_lvlpathcurrent.getInteger();
		if (settings.lvlpath.size() >0) {
        tmpstr = settings.lvlpath[curconfig] + CFGFILE;
		settings.loadConfigurations(tmpstr);
		}
       // if ( !settings.loadConfigurations(tmpstr) )
         //   throw SMF::Exception::CGeneralError("SMF::Exception::CGeneralError loading level settings");

        //resetting variables
        score=0;
        vulnflag= false;
        deadghostcount= 0;
        ghosttick = 0;
        floatingscorecounter = 0;
        floatingscore = 0;
        lives = 3;
        level = 1;
        objscore = 200;
        specialspawned = false;
        specialeaten = false;
        specialhasbeenspawned = false;
        inputwaiting = false;
        gamestarted = false;
        isboosted = false;
        time = oldtime = SDL_GetTicks();
        boostavailable = true;
        levelcleared = false;
		showHelp = false;
		if ( settings.lvlpath.size() >0 )
        setState( STATE_GAME);
        name = "AAA";
        namecol[0] = 255;
        namecol[1] = 150;
        namecol[2] = 150;
        hscoreselection = 0;


        if ( ispaused )
            pause();

        scorebox.x= 20;
        scorebox.w = 500;
        scorebox.y = settings.m_fieldheight.getInteger() * settings.m_tilesize.getInteger() ;
        scorebox.h = 50;



        //DYNAMIC OBJECTS INIT
		fieldMap.reset();
        objMap.reset();

		Debug::debug(Debug::gameEngine,__FUNCTION__) << " WILL DELETE OBJECTS==========================" << endl;

		if (objects[PAC]){ delete (Pacman *) objects[PAC]; objects[PAC] = NULL;}
		if (objects[BACKGROUND]) {delete (BckgrObj *) objects[BACKGROUND];objects[BACKGROUND] = NULL;}

		 for (i=2; i< NUMOFOBJECTS; i++) {

			if (objects[i]) {
				delete objects[i];
                objects[i] = NULL;
            }

          }
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "END DELETING OBJECTS==========================" << endl;
	    Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unloading complete" << endl;

        //if level has different field size than currently selected, setup new window with proper size
		if (settings.m_fieldwidth.getInteger()*settings.m_tilesize.getInteger() != SGF::CConfiguration::screenWidth.getInteger()
			|| settings.m_fieldheight.getInteger()*settings.m_tilesize.getInteger()+EXTRA_Y_SPACE != SGF::CConfiguration::screenHeight.getInteger()) {
           // app.InitWindow();
           //Todo Resize Window
				Debug::debug(Debug::error,__FUNCTION__)<<"window resized..."<<endl;
        }

        // INIT MAPS
		fieldMap.resize(settings.m_fieldheight.getInteger(),settings.m_fieldwidth.getInteger());
		objMap.resize(settings.m_fieldheight.getInteger(),settings.m_fieldwidth.getInteger());
		if (settings.lvlpath.size() >0) {
        
        tmpstr = settings.lvlpath[settings.m_lvlpathcurrent.getInteger()];
		
        if ( !fieldMap.loadCharMap(tmpstr + MAPFILE) )
            throw SMF::Exception::CGeneralError("Failed to load map.txt");
        if ( !objMap.loadCharMap(tmpstr + OBJFILE) )
            throw SMF::Exception::CGeneralError("Failed to load objmap.txt");

        Debug::debug(Debug::error,__FUNCTION__)<<"Maps loaded"<<endl;
		}
        //loading level graphics
		if (settings.skinspath.size() >0) {
        
        objects[BACKGROUND] = new BckgrObj(settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        Debug::debug(Debug::error,__FUNCTION__)<<"Level background loaded"<<endl;

		

       gameControl->getSnd()->play(9, 0);
	   }
        if (settings.lvlpath.size() >0) {
        setState( STATE_STOPPED);
        hscore.setfilename(settings.lvlpath[settings.m_lvlpathcurrent.getInteger()] + "hscore");
        hscore.load();
		}

        //create pacman + ghosts
		if (settings.skinspath.size() >0) {
        
        objects[1] = new Pacman(settings.m_pacstartx.getInteger(),
                            settings.m_pacstarty.getInteger(),
                            settings.m_pacspeed.getInteger(),
                            settings.m_tilesize.getInteger(),
                            settings.m_fieldheight.getInteger(),
                            settings.m_fieldwidth.getInteger(),
                            fieldMap,settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        objects[2] = new Ghost(settings.m_baddiestartx.getInteger(),
                            settings.m_baddiestarty.getInteger(),
                            settings.m_baddiespeed.getInteger() + rand()%20 + 10,
                            settings.m_tilesize.getInteger(),
                            settings.m_fieldheight.getInteger(),
                            settings.m_fieldwidth.getInteger(),
                            fieldMap,
                            "1", settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        objects[3] = new Ghost(settings.m_baddiestartx.getInteger()+2,
                            settings.m_baddiestarty.getInteger(),
                            settings.m_baddiespeed.getInteger() + rand()%20-10,
                            settings.m_tilesize.getInteger(),
                            settings.m_fieldheight.getInteger(),
                            settings.m_fieldwidth.getInteger(),
                            fieldMap,
                            "2",settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        objects[4] = new Ghost(settings.m_baddiestartx.getInteger()-2,
                            settings.m_baddiestarty.getInteger(),
                            settings.m_baddiespeed.getInteger() + rand()%20-10,
                            settings.m_tilesize.getInteger(),
                            settings.m_fieldheight.getInteger(),
                            settings.m_fieldwidth.getInteger(),
                            fieldMap,
                            "3",settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        objects[5] = new Ghost(settings.m_baddiestartx.getInteger(),
                            settings.m_baddiestarty.getInteger()-2,
                            settings.m_baddiespeed.getInteger() + rand()%20 - 10,
                            settings.m_tilesize.getInteger(),
                            settings.m_fieldheight.getInteger(),
                            settings.m_fieldwidth.getInteger(),
                            fieldMap,
                            "4",settings.skinspath[settings.m_skinspathcurrent.getInteger()]);

        for (i=0;i<4;i++) ((Ghost*)objects[i+2])->changeDifficulty(0, settings.m_baddieiq.getInteger());	//SET DIFFICULTY SPECIFIED IN CONFIG FILE

        Debug::debug(Debug::error,__FUNCTION__)<<"Objects loaded"<<endl;
		}
        //calculate special fruit spawn time

        if (!editor) act();
		if (objects[BACKGROUND]) 
        specialspawntime = rand() % (((BckgrObj*)objects[BACKGROUND])->getObjCount() -20) + 10;
		else specialspawntime =0;
        //emptyMsgPump();
        inputwaiting = false;
        gamestarted = false;

        isinit = true;

        if (editor) {
            initEditor();
            setState(STATE_EDITOR);
        }
    /*}
    catch ( SMF::Exception::CGeneralError &err) {
        std::cerr << err.getFullReason();
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch ( ... ) {
        std::cerr << "Unexpected exception in Game::gameInit()";
        gameControl->setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected error in Game::gameInit()" <<endl;
    } */
}


void Game::reloadLevel() {	// vars and positions when pacman dies during level

   gameControl->getSnd()->stop();

    SDL_Delay(1000);

   gameControl->getSnd()->play(9);


    // setting vars
    vulnflag= false;
    deadghostcount= 0;
    floatingscorecounter= 0;
    floatingscore= 0;
    ghosttick = 0;
    isboosted = false;
	showHelp = false;
    ((Pacman*)objects[PAC])->setSpeedMult( 1);

    if (ispaused) pause();

    objects[PAC]->reset();
    objects[GHOST1]->reset();
    objects[GHOST2]->reset();
    objects[GHOST3]->reset();
    objects[GHOST4]->reset();

   act();
    //emptyMsgPump();
    gamestarted= false;
    inputwaiting = false;
}
void Game::processInput(int k, int ix, int iy) {

    inputwaiting = true;

    key = k;
    if ( key == Click ) {
        mouseX = ix;
        mouseY = iy;
    }

    if ( !gamestarted && !ispaused ) {
        gamestarted = true;
        if ( state == STATE_STOPPED || state == STATE_GAME )
            setState( STATE_GAME );
    }
}

void Game::processLogic() {

    time = SDL_GetTicks();

    if ( state == STATE_GAME ) logicGame();
    else if (state == STATE_ENTER_HSCORE ) logicEnterHscore();
    else if (state == STATE_EDITOR ) logicEditor();

    oldtime = time;
    inputwaiting = false;
}

void Game::getMaps( SGF::CMap *m, SGF::CMap*o) {
    (*m)=fieldMap;
    (*o)=objMap;
}
void Game::act() {
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN RENDER GAME"<< endl;

    Colors::ColorDefinition
            col;

    col.r = col.g = col.b = 255;

   /* if (counter == 100) {   // a cada 100 execuções de render ele pega o valor de FPS
        fps = getFPS();
        counter = 0;
    } */

 //   try {
        if ( !renderisbusy ) {
            renderisbusy = true;

            ////////////////////////////////
            // STATE SWITCH
            ////////////////////////////////

            if ( (state == STATE_GAME) || (state == STATE_STOPPED) ) draw();
            else if (state == STATE_ENTER_HSCORE ) renderEnterHscore();
            else if (state == STATE_VIEW_HSCORE ) renderViewHscore();
            else if (state == STATE_EDITOR )renderEditor();

			if ( showfps ) {
				//if (CResource::getDefaultFont())
				CResource::getDefaultFont()->DrawTextNew(fpsbox.x,fpsbox.y,col,*this->gameControl->getScreen(),"%s",fps.c_str());

            }


            renderisbusy = false;
      //      counter++;
        }
  /*  }
    catch ( SMF::Exception::CGeneralError& err ) {
        //std::cerr << err.getFullReason();
        gameControl->setQuit(true);
         Debug::debug(Debug::gameEngine,__FUNCTION__) << err.getFullReason() << endl;
    }
    catch ( ... ) {
        gameControl->setQuit(true);
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception in Game::Render"<< endl;

    } */
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "END RENDER GAME"<< endl;
}


void Game::PrepareShutdown() {
    int i;
	for (i=0;i<NUMOFOBJECTS;i++) if ( objects[i] ) delete objects[i];
}
Game::Game()
:   isinit(false),
    state(STATE_STOPPED),
    counter(0),
    deadghostcount(0),
    lives(2),
    objscore(200),
    floatingscore(0),
    floatingscorecounter(0),
    specialspawntime(0),
    level(1),
    hscoreselection(0),
    soundcounter(0),
    inputwaiting(false),
    gamestarted(false),
    showHelp(false),
	vulnflag(false),
    specialspawned(false),
    specialeaten(false),
    specialhasbeenspawned(false),
    ispaused(false),
    isboosted(false),
    renderisbusy(false)

{
    int i;

    time = oldtime = ticks = SDL_GetTicks();

    fps = "loading";

    fpsbox.x= 10;
    fpsbox.w = 290;
    fpsbox.y = 10;
    fpsbox.h = 190;

    for (i=0;i<NUMOFOBJECTS;i++) objects[i]=NULL;

    for (i=0;i<10;i++)
        num[i]='0'+i;

    name = "AAA";
    namecol[0] = 255;
    namecol[1] = 150;
    namecol[2] = 150;
}

Game::~Game()
{


}

//Constructor
CPacGameControl::CPacGameControl():
pCurInputManager(NULL),  //! Deve inicializar o Input Manager
snd(NULL),
work(NULL),
quit(false)
{
	pCurInputManager=CInputManager::GetInstance();
}

//Destructor
CPacGameControl::~CPacGameControl()
{
	 Debug::debug(Debug::gameEngine,__FUNCTION__) << "BEGIN Deleting CPacGameControl" << endl;
	try {
        if ( snd ) {
            delete snd;
            snd = NULL;
        }
		Debug::debug(Debug::gameEngine,__FUNCTION__) << "END Deleting CPacGameControl" << endl;

    }

    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << (err.getFullReason() );
        setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch (...) {
        Debug::debug(Debug::gameEngine,__FUNCTION__) << "Unexpected exception"<<endl;
        setQuit(true);
        //Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected exception in App::~App()" <<endl;
    }
	Debug::debug(Debug::gameEngine,__FUNCTION__) << "END Deleting CPacGameControl" << endl;
}




void CPacGameControl::initSounds() {

	try {

        snd = new Sounds();
        snd->init();  //carrega os sons na memória

        Debug::debug(Debug::error,__FUNCTION__)<<"Sound initialized"<<endl;
    }
    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << (err.getFullReason() );
        setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch (...) {
        std::cerr << "Unexpected exception: "<< __FUNCTION__;
        setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected exception in App::InitSound()" <<endl;
    }

}

void  CPacGameControl::initWindow() {
    try {

		if ( work )
            delete work;
		work = new SGF::CBitmap(SGF::CConfiguration::screenWidth.getInteger(), SGF::CConfiguration::screenHeight.getInteger()+EXTRA_Y_SPACE);
		Debug::debug(Debug::error,__FUNCTION__)<<"WORK CREATED"<<endl;
		
        if (work == NULL)
            throw SMF::Exception::CGeneralError("SMF::Exception::CGeneralError while setting video mode");

        Debug::debug(Debug::error,__FUNCTION__)<<"Work Bitmap CREATED Sucessfully"<<endl;
    }
    catch ( SMF::Exception::CGeneralError& err ) {
        std::cerr << (err.getFullReason() );
        //setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< err.getFullReason() <<endl;
    }
    catch (...) {
        std::cerr << "Unexpected exception in: "<< __FUNCTION__;
        //setQuit(true);
        Debug::debug(Debug::error,__FUNCTION__)<< "Unexpected exception in CPacGameControl::App()" <<endl;
    }
}
